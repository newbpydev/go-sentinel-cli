
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>debouncer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/newbpydev/go-sentinel/internal/watch/debouncer/debouncer.go (93.3%)</option>

				<option value="file1">github.com/newbpydev/go-sentinel/internal/watch/debouncer/file_debouncer.go (100.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package debouncer provides event temporal processing capabilities
package debouncer

import (
        "sync"
        "time"

        "github.com/newbpydev/go-sentinel/internal/watch/core"
)

// Debouncer implements the EventDebouncer interface
type Debouncer struct {
        mu            sync.RWMutex
        interval      time.Duration
        events        chan []core.FileEvent
        pendingEvents map[string]core.FileEvent
        timer         *time.Timer
        stopCh        chan struct{}
        stopped       bool
}

// NewDebouncer creates a new event debouncer
func NewDebouncer(interval time.Duration) core.EventDebouncer <span class="cov8" title="1">{
        return &amp;Debouncer{
                interval:      interval,
                events:        make(chan []core.FileEvent, 10),
                pendingEvents: make(map[string]core.FileEvent),
                stopCh:        make(chan struct{}),
                stopped:       false,
        }
}</span>

// AddEvent implements the EventDebouncer interface
func (d *Debouncer) AddEvent(event core.FileEvent) <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        // Don't add events if stopped
        if d.stopped </span><span class="cov8" title="1">{
                return
        }</span>

        // Store the latest event for this path
        <span class="cov8" title="1">d.pendingEvents[event.Path] = event

        // Reset or start the timer
        if d.timer != nil </span><span class="cov8" title="1">{
                d.timer.Stop()
        }</span>

        <span class="cov8" title="1">d.timer = time.AfterFunc(d.interval, func() </span><span class="cov8" title="1">{
                d.flushPendingEvents()
        }</span>)
}

// Events implements the EventDebouncer interface
func (d *Debouncer) Events() &lt;-chan []core.FileEvent <span class="cov8" title="1">{
        return d.events
}</span>

// SetInterval implements the EventDebouncer interface
func (d *Debouncer) SetInterval(interval time.Duration) <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        d.interval = interval
}</span>

// Stop implements the EventDebouncer interface
func (d *Debouncer) Stop() error <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        if d.stopped </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">d.stopped = true

        // Stop the timer if it exists
        if d.timer != nil </span><span class="cov8" title="1">{
                d.timer.Stop()
                d.timer = nil
        }</span>

        // Flush any remaining events
        <span class="cov8" title="1">if len(d.pendingEvents) &gt; 0 </span><span class="cov8" title="1">{
                events := make([]core.FileEvent, 0, len(d.pendingEvents))
                for _, event := range d.pendingEvents </span><span class="cov8" title="1">{
                        events = append(events, event)
                }</span>

                // Send final events safely
                <span class="cov8" title="1">select </span>{
                case d.events &lt;- events:<span class="cov8" title="1"></span>
                default:<span class="cov0" title="0"></span>
                        // Channel might be full, that's ok
                }

                // Clear pending events
                <span class="cov8" title="1">d.pendingEvents = make(map[string]core.FileEvent)</span>
        }

        // Close the stop channel
        <span class="cov8" title="1">close(d.stopCh)

        // Close the events channel in a separate goroutine to avoid blocking
        go func() </span><span class="cov8" title="1">{
                time.Sleep(10 * time.Millisecond) // Small delay to ensure final events are processed
                close(d.events)
        }</span>()

        <span class="cov8" title="1">return nil</span>
}

// flushPendingEvents sends all pending events and clears the buffer
func (d *Debouncer) flushPendingEvents() <span class="cov8" title="1">{
        d.mu.Lock()
        defer d.mu.Unlock()

        // Don't flush if stopped
        if d.stopped </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if len(d.pendingEvents) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        // Convert map to slice
        <span class="cov8" title="1">events := make([]core.FileEvent, 0, len(d.pendingEvents))
        for _, event := range d.pendingEvents </span><span class="cov8" title="1">{
                events = append(events, event)
        }</span>

        // Clear pending events
        <span class="cov8" title="1">d.pendingEvents = make(map[string]core.FileEvent)

        // Send events safely
        select </span>{
        case d.events &lt;- events:<span class="cov8" title="1"></span>
        case &lt;-d.stopCh:<span class="cov0" title="0">
                // Debouncer was stopped, don't try to send
                return</span>
        default:<span class="cov0" title="0"></span>
                // Channel might be full, that's ok for now
        }
}
</pre>

		<pre class="file" id="file1" style="display: none">package debouncer

import (
        "sync"
        "time"

        "github.com/newbpydev/go-sentinel/internal/watch/core"
)

// FileEventDebouncer batches file events to avoid running tests too frequently
// Implements the core.EventDebouncer interface
type FileEventDebouncer struct {
        interval time.Duration
        events   chan []core.FileEvent
        input    chan core.FileEvent
        pending  map[string]core.FileEvent // Use map to deduplicate events by path
        timer    *time.Timer
        mutex    sync.Mutex
        stopCh   chan struct{}
        stopped  bool
}

// NewFileEventDebouncer creates a new file event debouncer
func NewFileEventDebouncer(interval time.Duration) *FileEventDebouncer <span class="cov8" title="1">{
        if interval &lt;= 0 </span><span class="cov8" title="1">{
                interval = 250 * time.Millisecond // Default debounce interval
        }</span>

        <span class="cov8" title="1">d := &amp;FileEventDebouncer{
                interval: interval,
                events:   make(chan []core.FileEvent, 10),
                input:    make(chan core.FileEvent, 100),
                pending:  make(map[string]core.FileEvent),
                stopCh:   make(chan struct{}),
        }

        go d.run()
        return d</span>
}

// AddEvent adds a file event to be debounced
// Implements core.EventDebouncer.AddEvent
func (d *FileEventDebouncer) AddEvent(event core.FileEvent) <span class="cov8" title="1">{
        d.mutex.Lock()
        stopped := d.stopped
        d.mutex.Unlock()

        if stopped </span><span class="cov8" title="1">{
                return // Early return if already stopped
        }</span>

        <span class="cov8" title="1">select </span>{
        case d.input &lt;- event:<span class="cov8" title="1"></span>
        case &lt;-d.stopCh:<span class="cov0" title="0"></span>
                // Debouncer is stopped, ignore new events
        default:<span class="cov0" title="0"></span>
                // Channel is full or closed, ignore the event
        }
}

// Events returns the channel for debounced events
// Implements core.EventDebouncer.Events
func (d *FileEventDebouncer) Events() &lt;-chan []core.FileEvent <span class="cov8" title="1">{
        return d.events
}</span>

// SetInterval configures the debounce interval
// Implements core.EventDebouncer.SetInterval
func (d *FileEventDebouncer) SetInterval(interval time.Duration) <span class="cov8" title="1">{
        d.mutex.Lock()
        defer d.mutex.Unlock()

        if interval &lt;= 0 </span><span class="cov8" title="1">{
                interval = 250 * time.Millisecond
        }</span>

        <span class="cov8" title="1">d.interval = interval</span>
}

// Stop stops the debouncer and closes channels
// Implements core.EventDebouncer.Stop
func (d *FileEventDebouncer) Stop() error <span class="cov8" title="1">{
        d.mutex.Lock()
        defer d.mutex.Unlock()

        if d.stopped </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">d.stopped = true

        // Stop the timer if it's running
        if d.timer != nil </span><span class="cov8" title="1">{
                d.timer.Stop()
                d.timer = nil
        }</span>

        // Close the stop channel first to signal the goroutine to stop
        <span class="cov8" title="1">close(d.stopCh)

        // Close the input channel to stop the run goroutine
        close(d.input)

        // Close the events channel after a brief delay to allow final events to be sent
        go func() </span><span class="cov8" title="1">{
                time.Sleep(10 * time.Millisecond)
                close(d.events)
        }</span>()

        <span class="cov8" title="1">return nil</span>
}

// run is the main debouncer loop
func (d *FileEventDebouncer) run() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case event, ok := &lt;-d.input:<span class="cov8" title="1">
                        if !ok </span><span class="cov8" title="1">{
                                // Input channel closed, flush any pending events and exit
                                d.flushPendingEvents()
                                return
                        }</span>

                        <span class="cov8" title="1">d.mutex.Lock()
                        // Add or update the event (newer events for the same path override older ones)
                        d.pending[event.Path] = event

                        // Reset the timer
                        if d.timer != nil </span><span class="cov8" title="1">{
                                d.timer.Stop()
                        }</span>
                        <span class="cov8" title="1">d.timer = time.AfterFunc(d.interval, func() </span><span class="cov8" title="1">{
                                d.flushPendingEvents()
                        }</span>)
                        <span class="cov8" title="1">d.mutex.Unlock()</span>

                case &lt;-d.stopCh:<span class="cov8" title="1">
                        return</span>
                }
        }
}

// flushPendingEvents sends all pending events and clears the pending map
func (d *FileEventDebouncer) flushPendingEvents() <span class="cov8" title="1">{
        d.mutex.Lock()
        defer d.mutex.Unlock()

        if len(d.pending) == 0 || d.stopped </span><span class="cov8" title="1">{
                return
        }</span>

        // Convert map to slice
        <span class="cov8" title="1">events := make([]core.FileEvent, 0, len(d.pending))
        for _, event := range d.pending </span><span class="cov8" title="1">{
                events = append(events, event)
        }</span>

        // Clear pending events first to prevent duplicate sends
        <span class="cov8" title="1">d.pending = make(map[string]core.FileEvent)

        // Send events (non-blocking) only if not stopped
        if !d.stopped </span><span class="cov8" title="1">{
                // Use a separate goroutine to avoid blocking the timer callback
                go func() </span><span class="cov8" title="1">{
                        select </span>{
                        case d.events &lt;- events:<span class="cov8" title="1"></span>
                                // Successfully sent events
                        case &lt;-d.stopCh:<span class="cov0" title="0"></span>
                                // Debouncer is stopped, don't send events
                        default:<span class="cov8" title="1"></span>
                                // Channel is full, skip this batch
                                // This prevents blocking if the consumer is slow
                        }
                }()
        }
}

// Ensure FileEventDebouncer implements the EventDebouncer interface
var _ core.EventDebouncer = (*FileEventDebouncer)(nil)
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
