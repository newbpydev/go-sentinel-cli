
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>watcher: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/newbpydev/go-sentinel/internal/watch/watcher/fs_watcher.go (89.3%)</option>

				<option value="file1">github.com/newbpydev/go-sentinel/internal/watch/watcher/patterns.go (95.6%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package watcher provides file system monitoring capabilities
package watcher

import (
        "context"
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "github.com/fsnotify/fsnotify"
        "github.com/newbpydev/go-sentinel/internal/watch/core"
)

// FileSystemWatcher watches for file changes in specified directories
// Implements the core.FileSystemWatcher interface
type FileSystemWatcher struct {
        watcher        *fsnotify.Watcher
        paths          []string
        ignorePatterns []string
        testPatterns   []string
}

// NewFileSystemWatcher creates a new FileSystemWatcher
func NewFileSystemWatcher(paths []string, ignorePatterns []string) (*FileSystemWatcher, error) <span class="cov8" title="1">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file watcher: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;FileSystemWatcher{
                watcher:        watcher,
                paths:          paths,
                ignorePatterns: ignorePatterns,
                testPatterns:   []string{"*_test.go"},
        }, nil</span>
}

// Watch starts monitoring for file changes and sends events to the channel
// Implements core.FileSystemWatcher.Watch
func (w *FileSystemWatcher) Watch(ctx context.Context, events chan&lt;- core.FileEvent) error <span class="cov8" title="1">{
        // Add all paths to the watcher
        for _, path := range w.paths </span><span class="cov8" title="1">{
                if err := w.AddPath(path); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }

        // Start watching for events
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>

                case event, ok := &lt;-w.watcher.Events:<span class="cov8" title="1">
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New("watcher channel closed")
                        }</span>

                        // Skip events for ignored files
                        <span class="cov8" title="1">if w.matchesAnyPattern(event.Name, w.ignorePatterns) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        // Only watch for write and create events
                        <span class="cov8" title="1">if event.Op&amp;(fsnotify.Write|fsnotify.Create) == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        // Skip directories
                        <span class="cov8" title="1">info, err := os.Stat(event.Name)
                        if err == nil &amp;&amp; info.IsDir() </span><span class="cov8" title="1">{
                                // Add the new directory to the watcher
                                if err := w.watcher.Add(event.Name); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to add new directory %s to watcher: %w", event.Name, err)
                                }</span>
                                <span class="cov8" title="1">continue</span>
                        }

                        // Determine if this is a test file
                        <span class="cov8" title="1">isTest := w.matchesAnyPattern(event.Name, w.testPatterns)

                        // Send the event
                        select </span>{
                        case events &lt;- core.FileEvent{
                                Path:      event.Name,
                                Type:      w.eventTypeString(event.Op),
                                Timestamp: time.Now(),
                                IsTest:    isTest,
                        }:<span class="cov8" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov8" title="1">
                                return ctx.Err()</span>
                        }

                case err, ok := &lt;-w.watcher.Errors:<span class="cov0" title="0">
                        if !ok </span><span class="cov0" title="0">{
                                return errors.New("watcher error channel closed")
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("watcher error: %w", err)</span>
                }
        }
}

// AddPath adds a new path to be monitored
// Implements core.FileSystemWatcher.AddPath
func (w *FileSystemWatcher) AddPath(path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("path cannot be empty")
        }</span>

        <span class="cov8" title="1">absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute path for %s: %w", path, err)
        }</span>

        // Add the directory itself
        <span class="cov8" title="1">info, err := os.Stat(absPath)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to stat path %s: %w", absPath, err)
        }</span>

        <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                // Walk through all subdirectories
                err = filepath.Walk(absPath, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                                // Skip directories that match ignore patterns
                                if w.matchesAnyPattern(path, w.ignorePatterns) </span><span class="cov8" title="1">{
                                        return filepath.SkipDir
                                }</span>

                                // Add directory to watcher
                                <span class="cov8" title="1">if err := w.watcher.Add(path); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("failed to add directory %s to watcher: %w", path, err)
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                })

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to walk directory %s: %w", absPath, err)
                }</span>
        } else<span class="cov8" title="1"> {
                // Add the single file to the watcher
                if err := w.watcher.Add(filepath.Dir(absPath)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to add file %s to watcher: %w", absPath, err)
                }</span>
        }

        // Add to paths list if not already present
        <span class="cov8" title="1">for _, existingPath := range w.paths </span><span class="cov8" title="1">{
                if existingPath == path </span><span class="cov8" title="1">{
                        return nil // Already exists
                }</span>
        }
        <span class="cov8" title="1">w.paths = append(w.paths, path)
        return nil</span>
}

// RemovePath removes a path from monitoring
// Implements core.FileSystemWatcher.RemovePath
func (w *FileSystemWatcher) RemovePath(path string) error <span class="cov8" title="1">{
        if path == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("path cannot be empty")
        }</span>

        <span class="cov8" title="1">absPath, err := filepath.Abs(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get absolute path for %s: %w", path, err)
        }</span>

        // Remove from fsnotify watcher
        <span class="cov8" title="1">if err := w.watcher.Remove(absPath); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("failed to remove path %s from watcher: %w", absPath, err)
        }</span>

        // Remove from paths list
        <span class="cov8" title="1">for i, existingPath := range w.paths </span><span class="cov8" title="1">{
                if existingPath == path </span><span class="cov8" title="1">{
                        w.paths = append(w.paths[:i], w.paths[i+1:]...)
                        break</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// Close releases all resources used by the watcher
// Implements core.FileSystemWatcher.Close
func (w *FileSystemWatcher) Close() error <span class="cov8" title="1">{
        return w.watcher.Close()
}</span>

// matchesAnyPattern checks if a path matches any of the provided patterns
func (w *FileSystemWatcher) matchesAnyPattern(path string, patterns []string) bool <span class="cov8" title="1">{
        if len(patterns) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        // Use PatternMatcher for consistent pattern matching
        <span class="cov8" title="1">matcher := NewPatternMatcher()
        return matcher.MatchesAny(path, patterns)</span>
}

// eventTypeString converts fsnotify operation to string
func (w *FileSystemWatcher) eventTypeString(op fsnotify.Op) string <span class="cov8" title="1">{
        switch </span>{
        case op&amp;fsnotify.Create != 0:<span class="cov8" title="1">
                return "create"</span>
        case op&amp;fsnotify.Write != 0:<span class="cov8" title="1">
                return "write"</span>
        case op&amp;fsnotify.Remove != 0:<span class="cov8" title="1">
                return "remove"</span>
        case op&amp;fsnotify.Rename != 0:<span class="cov8" title="1">
                return "rename"</span>
        case op&amp;fsnotify.Chmod != 0:<span class="cov8" title="1">
                return "chmod"</span>
        default:<span class="cov8" title="1">
                return "unknown"</span>
        }
}

// TestFileFinder helps find test files related to implementation files
// Implements the core.TestFileFinder interface
type TestFileFinder struct {
        rootDir string
}

// NewTestFileFinder creates a new TestFileFinder
func NewTestFileFinder(rootDir string) *TestFileFinder <span class="cov8" title="1">{
        return &amp;TestFileFinder{
                rootDir: rootDir,
        }
}</span>

// FindTestFile finds the test file corresponding to the given implementation file
// Implements core.TestFileFinder.FindTestFile
func (f *TestFileFinder) FindTestFile(filePath string) (string, error) <span class="cov8" title="1">{
        if filePath == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("file path cannot be empty")
        }</span>

        // If it's already a test file, just return it
        <span class="cov8" title="1">if strings.HasSuffix(filePath, "_test.go") </span><span class="cov8" title="1">{
                return filePath, nil
        }</span>

        // Construct the expected test file path
        <span class="cov8" title="1">dir := filepath.Dir(filePath)
        base := filepath.Base(filePath)
        ext := filepath.Ext(base)
        name := strings.TrimSuffix(base, ext)
        testFile := filepath.Join(dir, name+"_test"+ext)

        // Check if the test file exists
        _, err := os.Stat(testFile)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("test file not found for %s: %w", filePath, err)
        }</span>

        <span class="cov8" title="1">return testFile, nil</span>
}

// FindImplementationFile finds the implementation file for a given test file
// Implements core.TestFileFinder.FindImplementationFile
func (f *TestFileFinder) FindImplementationFile(testPath string) (string, error) <span class="cov8" title="1">{
        if testPath == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("test path cannot be empty")
        }</span>

        <span class="cov8" title="1">if !strings.HasSuffix(testPath, "_test.go") </span><span class="cov8" title="1">{
                return "", fmt.Errorf("not a test file: %s", testPath)
        }</span>

        // Construct the expected implementation file path
        <span class="cov8" title="1">dir := filepath.Dir(testPath)
        base := filepath.Base(testPath)
        name := strings.TrimSuffix(base, "_test.go")
        implFile := filepath.Join(dir, name+".go")

        // Check if the implementation file exists
        _, err := os.Stat(implFile)
        if err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("implementation file not found for %s: %w", testPath, err)
        }</span>

        <span class="cov8" title="1">return implFile, nil</span>
}

// FindPackageTests finds all test files in the same package as the given file
// Implements core.TestFileFinder.FindPackageTests
func (f *TestFileFinder) FindPackageTests(filePath string) ([]string, error) <span class="cov8" title="1">{
        if filePath == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("file path cannot be empty")
        }</span>

        <span class="cov8" title="1">dir := filepath.Dir(filePath)

        // Read all files in the directory
        entries, err := os.ReadDir(dir)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to read directory %s: %w", dir, err)
        }</span>

        // Filter for test files
        <span class="cov8" title="1">var testFiles []string
        for _, entry := range entries </span><span class="cov8" title="1">{
                if entry.IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">name := entry.Name()
                if strings.HasSuffix(name, "_test.go") </span><span class="cov8" title="1">{
                        testFiles = append(testFiles, filepath.Join(dir, name))
                }</span>
        }

        <span class="cov8" title="1">if len(testFiles) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no test files found in %s", dir)
        }</span>

        <span class="cov8" title="1">return testFiles, nil</span>
}

// IsTestFile determines if the given file is a test file
// Implements core.TestFileFinder.IsTestFile
func (f *TestFileFinder) IsTestFile(filePath string) bool <span class="cov8" title="1">{
        return strings.HasSuffix(filePath, "_test.go")
}</span>

// Ensure FileSystemWatcher implements the FileSystemWatcher interface
var _ core.FileSystemWatcher = (*FileSystemWatcher)(nil)

// Ensure TestFileFinder implements the TestFileFinder interface
var _ core.TestFileFinder = (*TestFileFinder)(nil)
</pre>

		<pre class="file" id="file1" style="display: none">// Package watcher provides pattern matching capabilities for file paths
package watcher

import (
        "path/filepath"
        "strings"

        "github.com/newbpydev/go-sentinel/internal/watch/core"
)

// PatternMatcher implements the core.PatternMatcher interface
type PatternMatcher struct {
        patterns []core.FilePattern
}

// NewPatternMatcher creates a new pattern matcher
func NewPatternMatcher() core.PatternMatcher <span class="cov8" title="1">{
        return &amp;PatternMatcher{
                patterns: make([]core.FilePattern, 0),
        }
}</span>

// MatchesAny implements the PatternMatcher interface
func (pm *PatternMatcher) MatchesAny(path string, patterns []string) bool <span class="cov8" title="1">{
        // Normalize path for cross-platform compatibility
        cleanPath := filepath.ToSlash(path)

        for _, pattern := range patterns </span><span class="cov8" title="1">{
                if pm.MatchesPattern(cleanPath, pattern) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// MatchesPattern implements the PatternMatcher interface
func (pm *PatternMatcher) MatchesPattern(path string, pattern string) bool <span class="cov8" title="1">{
        if path == "" || pattern == "" </span><span class="cov8" title="1">{
                return false
        }</span>

        // Normalize paths for cross-platform compatibility
        <span class="cov8" title="1">normalizedPath := filepath.ToSlash(path)
        normalizedPattern := filepath.ToSlash(pattern)

        // Exact match first
        if normalizedPath == normalizedPattern </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check exact filename match
        <span class="cov8" title="1">if filepath.Base(normalizedPath) == normalizedPattern </span><span class="cov8" title="1">{
                return true
        }</span>

        // Wildcard matching using filepath.Match for filename
        <span class="cov8" title="1">if matched, err := filepath.Match(normalizedPattern, filepath.Base(normalizedPath)); err == nil &amp;&amp; matched </span><span class="cov8" title="1">{
                return true
        }</span>

        // Full path wildcard matching
        <span class="cov8" title="1">if matched, err := filepath.Match(normalizedPattern, normalizedPath); err == nil &amp;&amp; matched </span><span class="cov8" title="1">{
                return true
        }</span>

        // Directory pattern matching
        <span class="cov8" title="1">pathComponents := strings.Split(normalizedPath, "/")

        // Check if pattern matches any directory component
        for _, component := range pathComponents </span><span class="cov8" title="1">{
                if component == normalizedPattern </span><span class="cov8" title="1">{
                        return true
                }</span>
                // Wildcard match against directory component
                <span class="cov8" title="1">if matched, err := filepath.Match(normalizedPattern, component); err == nil &amp;&amp; matched </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        // Directory prefix matching (src/ should match src/main.go)
        <span class="cov8" title="1">if strings.HasSuffix(normalizedPattern, "/") </span><span class="cov8" title="1">{
                prefix := strings.TrimSuffix(normalizedPattern, "/")
                if strings.HasPrefix(normalizedPath, prefix+"/") </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        // Directory contains matching (src should match src/main.go)
        <span class="cov8" title="1">if strings.Contains(normalizedPath, "/"+normalizedPattern+"/") ||
                strings.HasPrefix(normalizedPath, normalizedPattern+"/") </span><span class="cov0" title="0">{
                return true
        }</span>

        // Recursive pattern matching (**)
        <span class="cov8" title="1">if strings.Contains(normalizedPattern, "**") </span><span class="cov8" title="1">{
                parts := strings.Split(normalizedPattern, "**")
                if len(parts) &gt;= 2 </span><span class="cov8" title="1">{
                        prefix := strings.TrimSuffix(parts[0], "/")
                        if prefix == "" || strings.Contains(normalizedPath, prefix) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// AddPattern implements the PatternMatcher interface
func (pm *PatternMatcher) AddPattern(pattern string) error <span class="cov8" title="1">{
        filePattern := core.FilePattern{
                Pattern:       pattern,
                Type:          core.PatternTypeGlob, // Default to glob
                Recursive:     strings.Contains(pattern, "**"),
                CaseSensitive: true, // Default to case sensitive
        }

        pm.patterns = append(pm.patterns, filePattern)
        return nil
}</span>

// RemovePattern implements the PatternMatcher interface
func (pm *PatternMatcher) RemovePattern(pattern string) error <span class="cov8" title="1">{
        for i, p := range pm.patterns </span><span class="cov8" title="1">{
                if p.Pattern == pattern </span><span class="cov8" title="1">{
                        pm.patterns = append(pm.patterns[:i], pm.patterns[i+1:]...)
                        return nil
                }</span>
        }
        <span class="cov8" title="1">return nil</span> // Pattern not found, but that's not an error
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
