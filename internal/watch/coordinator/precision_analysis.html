
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>coordinator: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/newbpydev/go-sentinel/internal/watch/coordinator/coordinator.go (100.0%)</option>

				<option value="file1">github.com/newbpydev/go-sentinel/internal/watch/coordinator/watch_coordinator.go (93.5%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">// Package coordinator provides watch system orchestration capabilities
package coordinator

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/newbpydev/go-sentinel/internal/watch/core"
        "github.com/newbpydev/go-sentinel/pkg/models"
)

// Coordinator implements the WatchCoordinator interface
type Coordinator struct {
        mu           sync.RWMutex
        fsWatcher    core.FileSystemWatcher
        debouncer    core.EventDebouncer
        testTrigger  core.TestTrigger
        options      core.WatchOptions
        status       core.WatchStatus
        eventChannel chan core.FileEvent
        ctx          context.Context
        cancel       context.CancelFunc
        stopCh       chan struct{}
        stopped      bool
}

// NewCoordinator creates a new watch coordinator
func NewCoordinator(
        fsWatcher core.FileSystemWatcher,
        debouncer core.EventDebouncer,
        testTrigger core.TestTrigger,
) core.WatchCoordinator <span class="cov8" title="1">{
        return &amp;Coordinator{
                fsWatcher:    fsWatcher,
                debouncer:    debouncer,
                testTrigger:  testTrigger,
                eventChannel: make(chan core.FileEvent, 100),
                stopCh:       make(chan struct{}),
                stopped:      false,
                status: core.WatchStatus{
                        IsRunning:    false,
                        WatchedPaths: []string{},
                        Mode:         core.WatchAll,
                        EventCount:   0,
                        ErrorCount:   0,
                },
        }
}</span>

// Start implements the WatchCoordinator interface
func (c *Coordinator) Start(ctx context.Context) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.status.IsRunning </span><span class="cov8" title="1">{
                return models.NewWatchError("start", "", nil).
                        WithContext("reason", "already_running").
                        WithContext("component", "coordinator")
        }</span>

        // Create context for this watch session
        <span class="cov8" title="1">c.ctx, c.cancel = context.WithCancel(ctx)

        // Update status
        c.status.IsRunning = true
        c.status.StartTime = time.Now()
        c.status.WatchedPaths = c.options.Paths

        // Start the file system watcher
        if err := c.fsWatcher.Watch(c.ctx, c.eventChannel); err != nil &amp;&amp; err != context.Canceled </span><span class="cov8" title="1">{
                c.status.ErrorCount++ // Direct increment since we already hold the lock
                return models.NewWatchError("start_file_watcher", "", err).
                        WithContext("component", "file_watcher")
        }</span>

        // Start the event processing loop
        <span class="cov8" title="1">go c.processEvents()

        return nil</span>
}

// Stop implements the WatchCoordinator interface
func (c *Coordinator) Stop() error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        if c.stopped </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">c.stopped = true

        // Cancel the context to stop the file system watcher
        if c.cancel != nil </span><span class="cov8" title="1">{
                c.cancel()
        }</span>

        // Stop the debouncer
        <span class="cov8" title="1">if err := c.debouncer.Stop(); err != nil </span><span class="cov8" title="1">{
                c.status.ErrorCount++
                return models.NewWatchError("stop_debouncer", "", err).
                        WithContext("component", "debouncer")
        }</span>

        // Close the file system watcher
        <span class="cov8" title="1">if err := c.fsWatcher.Close(); err != nil </span><span class="cov8" title="1">{
                c.status.ErrorCount++
                return models.NewWatchError("stop_file_watcher", "", err).
                        WithContext("component", "file_watcher")
        }</span>

        // Close channels
        <span class="cov8" title="1">close(c.stopCh)
        close(c.eventChannel)

        // Update status
        c.status.IsRunning = false

        return nil</span>
}

// HandleFileChanges implements the WatchCoordinator interface
func (c *Coordinator) HandleFileChanges(changes []core.FileEvent) error <span class="cov8" title="1">{
        c.mu.RLock()

        if !c.status.IsRunning </span><span class="cov8" title="1">{
                c.mu.RUnlock()
                return models.NewWatchError("handle_changes", "", nil).
                        WithContext("reason", "not_running").
                        WithContext("component", "coordinator")
        }</span>

        // Update last event time
        <span class="cov8" title="1">c.status.LastEventTime = time.Now()

        // Get values we need while holding the lock
        mode := c.options.Mode
        ctx := c.ctx
        c.mu.RUnlock()

        // Trigger tests based on watch mode (without holding lock)
        switch mode </span>{
        case core.WatchAll:<span class="cov8" title="1">
                for _, change := range changes </span><span class="cov8" title="1">{
                        if err := c.testTrigger.TriggerTestsForFile(ctx, change.Path); err != nil </span><span class="cov8" title="1">{
                                c.incrementErrorCount()
                                return models.NewWatchError("trigger_tests", change.Path, err).
                                        WithContext("mode", "watch_all").
                                        WithContext("change_type", change.Type)
                        }</span>
                }

        case core.WatchChanged:<span class="cov8" title="1">
                for _, change := range changes </span><span class="cov8" title="1">{
                        if err := c.testTrigger.TriggerTestsForFile(ctx, change.Path); err != nil </span><span class="cov8" title="1">{
                                c.incrementErrorCount()
                                return models.NewWatchError("trigger_tests", change.Path, err).
                                        WithContext("mode", "watch_changed").
                                        WithContext("change_type", change.Type)
                        }</span>
                }

        case core.WatchRelated:<span class="cov8" title="1">
                for _, change := range changes </span><span class="cov8" title="1">{
                        if err := c.testTrigger.TriggerRelatedTests(ctx, change.Path); err != nil </span><span class="cov8" title="1">{
                                c.incrementErrorCount()
                                return models.NewWatchError("trigger_related_tests", change.Path, err).
                                        WithContext("mode", "watch_related").
                                        WithContext("change_type", change.Type)
                        }</span>
                }

        default:<span class="cov8" title="1">
                return models.NewWatchError("handle_changes", "", nil).
                        WithContext("reason", "unknown_mode").
                        WithContext("mode", string(mode))</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Configure implements the WatchCoordinator interface
func (c *Coordinator) Configure(options core.WatchOptions) error <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        // Store the options
        c.options = options

        // Configure the debouncer interval
        c.debouncer.SetInterval(options.DebounceInterval)

        // Update watch mode in status
        c.status.Mode = options.Mode

        return nil
}</span>

// GetStatus implements the WatchCoordinator interface
func (c *Coordinator) GetStatus() core.WatchStatus <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()

        // Return a copy of the status
        return c.status
}</span>

// processEvents handles the event processing loop
func (c *Coordinator) processEvents() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                case event := &lt;-c.eventChannel:<span class="cov8" title="1">
                        c.incrementEventCount()
                        c.debouncer.AddEvent(event)</span>

                case debouncedEvents := &lt;-c.debouncer.Events():<span class="cov8" title="1">
                        if len(debouncedEvents) &gt; 0 </span><span class="cov8" title="1">{
                                if err := c.HandleFileChanges(debouncedEvents); err != nil </span><span class="cov8" title="1">{
                                        c.incrementErrorCount()
                                        fmt.Printf("Error handling file changes: %v\n", err)
                                }</span>
                        }

                case &lt;-c.stopCh:<span class="cov8" title="1">
                        return</span>

                case &lt;-c.ctx.Done():<span class="cov8" title="1">
                        return</span>
                }
        }
}

// incrementEventCount safely increments the event count
func (c *Coordinator) incrementEventCount() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.status.EventCount++
}</span>

// incrementErrorCount safely increments the error count
func (c *Coordinator) incrementErrorCount() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.status.ErrorCount++
}</span>
</pre>

		<pre class="file" id="file1" style="display: none">// Package coordinator provides watch mode orchestration and coordination
package coordinator

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "time"

        "github.com/newbpydev/go-sentinel/internal/test/processor"
        "github.com/newbpydev/go-sentinel/internal/test/runner"
        "github.com/newbpydev/go-sentinel/internal/watch/core"
        "github.com/newbpydev/go-sentinel/internal/watch/debouncer"
        "github.com/newbpydev/go-sentinel/internal/watch/watcher"
)

// TestWatchCoordinator runs tests in watch mode and implements core.WatchCoordinator
type TestWatchCoordinator struct {
        options       core.WatchOptions
        fileWatcher   core.FileSystemWatcher
        testRunner    runner.TestRunnerInterface
        testFinder    core.TestFileFinder
        processor     *processor.TestProcessor
        debouncer     core.EventDebouncer
        terminalWidth int
        status        core.WatchStatus
}

// NewTestWatchCoordinator creates a new TestWatchCoordinator
func NewTestWatchCoordinator(options core.WatchOptions) (*TestWatchCoordinator, error) <span class="cov8" title="1">{
        if options.Writer == nil </span><span class="cov0" title="0">{
                options.Writer = os.Stdout
        }</span>

        <span class="cov8" title="1">if options.DebounceInterval == 0 </span><span class="cov8" title="1">{
                options.DebounceInterval = 500 * time.Millisecond
        }</span>

        // Set default test patterns if not provided
        <span class="cov8" title="1">if len(options.TestPatterns) == 0 </span><span class="cov8" title="1">{
                options.TestPatterns = []string{"*_test.go"}
        }</span>

        // Set default ignore patterns if not provided
        <span class="cov8" title="1">if len(options.IgnorePatterns) == 0 </span><span class="cov8" title="1">{
                options.IgnorePatterns = []string{
                        "*/vendor/*",
                        "*/.git/*",
                        "*/node_modules/*",
                }
        }</span>

        // Create file watcher
        <span class="cov8" title="1">fsWatcher, err := watcher.NewFileSystemWatcher(options.Paths, options.IgnorePatterns)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create file watcher: %w", err)
        }</span>

        // Set up test finder
        <span class="cov8" title="1">rootDir := "."
        if len(options.Paths) &gt; 0 </span><span class="cov8" title="1">{
                rootDir = options.Paths[0]
        }</span>
        <span class="cov8" title="1">finder := watcher.NewTestFileFinder(rootDir)

        // Get terminal width
        terminalWidth := 80

        // Create test runner
        testRunner := runner.NewTestRunner(true, true) // verbose and JSON output

        // Create debouncer
        eventDebouncer := debouncer.NewFileEventDebouncer(options.DebounceInterval)

        // Initialize status
        status := core.WatchStatus{
                IsRunning:     false,
                WatchedPaths:  options.Paths,
                Mode:          options.Mode,
                StartTime:     time.Now(),
                LastEventTime: time.Time{},
                EventCount:    0,
                ErrorCount:    0,
        }

        return &amp;TestWatchCoordinator{
                options:       options,
                fileWatcher:   fsWatcher,
                testRunner:    testRunner,
                testFinder:    finder,
                debouncer:     eventDebouncer,
                terminalWidth: terminalWidth,
                status:        status,
        }, nil</span>
}

// Start begins watching for file changes and implements core.WatchCoordinator.Start
func (w *TestWatchCoordinator) Start(ctx context.Context) error <span class="cov8" title="1">{
        w.status.IsRunning = true
        defer func() </span><span class="cov8" title="1">{ w.status.IsRunning = false }</span>()

        // Display initial status message
        <span class="cov8" title="1">w.printStatus("Watching for file changes...")

        // Create channel for file events
        fileEvents := make(chan core.FileEvent, 100)

        // Start watching for file changes
        watchCtx, watchCancel := context.WithCancel(ctx)
        defer watchCancel()

        go func() </span><span class="cov8" title="1">{
                if err := w.fileWatcher.Watch(watchCtx, fileEvents); err != nil &amp;&amp; err != context.Canceled </span><span class="cov8" title="1">{
                        fmt.Fprintf(w.options.Writer, "Watch error: %v\n", err)
                }</span>
        }()

        // Start event processing
        <span class="cov8" title="1">go w.processFileEvents(fileEvents)

        // Run tests on start if in WatchAll mode or RunOnStart is enabled
        if w.options.Mode == core.WatchAll || w.options.RunOnStart </span><span class="cov8" title="1">{
                w.runAllTests()
        }</span>

        // Process debounced events
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return ctx.Err()</span>

                case debouncedEvents := &lt;-w.debouncer.Events():<span class="cov0" title="0">
                        if err := w.HandleFileChanges(debouncedEvents); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(w.options.Writer, "Error handling file changes: %v\n", err)
                        }</span>
                }
        }
}

// Stop stops the watcher and implements core.WatchCoordinator.Stop
func (w *TestWatchCoordinator) Stop() error <span class="cov8" title="1">{
        var errs []error

        if err := w.debouncer.Stop(); err != nil </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("debouncer stop error: %w", err))
        }</span>

        <span class="cov8" title="1">if err := w.fileWatcher.Close(); err != nil </span><span class="cov8" title="1">{
                errs = append(errs, fmt.Errorf("file watcher close error: %w", err))
        }</span>

        <span class="cov8" title="1">w.status.IsRunning = false

        if len(errs) &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("errors during stop: %v", errs)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// HandleFileChanges processes a batch of file changes and implements core.WatchCoordinator.HandleFileChanges
func (w *TestWatchCoordinator) HandleFileChanges(changes []core.FileEvent) error <span class="cov8" title="1">{
        if len(changes) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Update status
        <span class="cov8" title="1">w.status.LastEventTime = time.Now()

        // Clear terminal if requested
        if w.options.ClearTerminal </span><span class="cov8" title="1">{
                w.clearTerminal()
        }</span>

        // Process each change
        <span class="cov8" title="1">for _, change := range changes </span><span class="cov8" title="1">{
                // Display file change notification
                fileName := filepath.Base(change.Path)
                w.printStatus(fmt.Sprintf("File changed: %s", fileName))

                // Run appropriate tests based on watch mode
                switch w.options.Mode </span>{
                case core.WatchAll:<span class="cov8" title="1">
                        w.runAllTests()</span>

                case core.WatchChanged:<span class="cov8" title="1">
                        if err := w.runTestsForFile(change.Path); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(w.options.Writer, "Error running tests for %s: %v\n", change.Path, err)
                        }</span>

                case core.WatchRelated:<span class="cov8" title="1">
                        if err := w.runRelatedTests(change.Path); err != nil </span><span class="cov0" title="0">{
                                fmt.Fprintf(w.options.Writer, "Error running related tests for %s: %v\n", change.Path, err)
                        }</span>
                }

                <span class="cov8" title="1">w.status.EventCount++</span>
        }

        // Display watch mode info
        <span class="cov8" title="1">w.printWatchInfo()
        return nil</span>
}

// Configure updates the watch system configuration and implements core.WatchCoordinator.Configure
func (w *TestWatchCoordinator) Configure(options core.WatchOptions) error <span class="cov8" title="1">{
        w.options = options

        // Update debouncer interval
        w.debouncer.SetInterval(options.DebounceInterval)

        // TODO: Update file watcher paths if needed
        // This would require stopping and restarting the watcher

        return nil
}</span>

// GetStatus returns the current status and implements core.WatchCoordinator.GetStatus
func (w *TestWatchCoordinator) GetStatus() core.WatchStatus <span class="cov8" title="1">{
        return w.status
}</span>

// processFileEvents processes incoming file events through the debouncer
func (w *TestWatchCoordinator) processFileEvents(fileEvents &lt;-chan core.FileEvent) <span class="cov8" title="1">{
        for event := range fileEvents </span><span class="cov8" title="1">{
                w.debouncer.AddEvent(event)
        }</span>
}

// runAllTests runs all tests in the workspace
func (w *TestWatchCoordinator) runAllTests() <span class="cov8" title="1">{
        w.printStatus("Running all tests...")

        // Run tests for all packages
        packages := []string{"./..."}
        if err := w.executeTests(packages); err != nil </span><span class="cov8" title="1">{
                fmt.Fprintf(w.options.Writer, "Error running all tests: %v\n", err)
        }</span>
}

// runTestsForFile runs tests for a specific file
func (w *TestWatchCoordinator) runTestsForFile(filePath string) error <span class="cov8" title="1">{
        var testTargets []string

        if w.testFinder.IsTestFile(filePath) </span><span class="cov8" title="1">{
                // It's a test file, run it directly
                testTargets = []string{filepath.Dir(filePath)}
        }</span> else<span class="cov8" title="1"> {
                // Find corresponding test file
                testFile, err := w.testFinder.FindTestFile(filePath)
                if err != nil </span><span class="cov8" title="1">{
                        // No specific test file found, run all tests in the package
                        testTargets = []string{filepath.Dir(filePath)}
                }</span> else<span class="cov8" title="1"> {
                        testTargets = []string{filepath.Dir(testFile)}
                }</span>
        }

        <span class="cov8" title="1">w.printStatus(fmt.Sprintf("Running tests for: %s", filepath.Base(filePath)))
        return w.executeTests(testTargets)</span>
}

// runRelatedTests runs tests related to the changed file
func (w *TestWatchCoordinator) runRelatedTests(filePath string) error <span class="cov8" title="1">{
        var testTargets []string

        if w.testFinder.IsTestFile(filePath) </span><span class="cov8" title="1">{
                // It's a test file, find its implementation and run all package tests
                implFile, err := w.testFinder.FindImplementationFile(filePath)
                if err == nil </span><span class="cov8" title="1">{
                        // Run tests for both the test file and its package
                        testTargets = append(testTargets, filepath.Dir(filePath))
                        if implDir := filepath.Dir(implFile); implDir != filepath.Dir(filePath) </span><span class="cov8" title="1">{
                                testTargets = append(testTargets, implDir)
                        }</span>
                } else<span class="cov8" title="1"> {
                        // Just run the test file
                        testTargets = []string{filepath.Dir(filePath)}
                }</span>
        } else<span class="cov8" title="1"> {
                // It's a source file, find all related tests
                packageTests, err := w.testFinder.FindPackageTests(filePath)
                if err != nil </span><span class="cov8" title="1">{
                        // No tests found, run package tests
                        testTargets = []string{filepath.Dir(filePath)}
                }</span> else<span class="cov8" title="1"> {
                        // Add unique directories
                        dirSet := make(map[string]bool)
                        for _, testFile := range packageTests </span><span class="cov8" title="1">{
                                dirSet[filepath.Dir(testFile)] = true
                        }</span>
                        <span class="cov8" title="1">for dir := range dirSet </span><span class="cov8" title="1">{
                                testTargets = append(testTargets, dir)
                        }</span>
                }
        }

        <span class="cov8" title="1">w.printStatus(fmt.Sprintf("Running related tests for: %s", filepath.Base(filePath)))
        return w.executeTests(testTargets)</span>
}

// executeTests runs tests for the specified targets
func (w *TestWatchCoordinator) executeTests(targets []string) error <span class="cov8" title="1">{
        if len(targets) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        // Remove duplicates
        <span class="cov8" title="1">uniqueTargets := make([]string, 0, len(targets))
        seen := make(map[string]bool)
        for _, target := range targets </span><span class="cov8" title="1">{
                if !seen[target] </span><span class="cov8" title="1">{
                        uniqueTargets = append(uniqueTargets, target)
                        seen[target] = true
                }</span>
        }

        // Create context for test execution
        <span class="cov8" title="1">ctx := context.Background()

        // Execute tests using the test runner
        output, err := w.testRunner.Run(ctx, uniqueTargets)
        if err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("test execution failed: %w", err)
        }</span>

        // Process the JSON output if we have a processor configured and there's output
        <span class="cov8" title="1">if w.processor != nil &amp;&amp; output != "" </span><span class="cov8" title="1">{
                if err := w.processor.ProcessJSONOutput(output); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(w.options.Writer, "Error processing test output: %v\n", err)
                }</span>

                <span class="cov8" title="1">if err := w.processor.RenderResults(true); err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(w.options.Writer, "Error rendering results: %v\n", err)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// printStatus displays a status message
func (w *TestWatchCoordinator) printStatus(message string) <span class="cov8" title="1">{
        timestamp := time.Now().Format("15:04:05")
        fmt.Fprintf(w.options.Writer, "[%s] %s\n", timestamp, message)
}</span>

// printWatchInfo displays information about the watch mode
func (w *TestWatchCoordinator) printWatchInfo() <span class="cov8" title="1">{
        fmt.Fprintf(w.options.Writer, "\nðŸ‘€ Watching for changes... (mode: %s)\n", w.options.Mode)
        fmt.Fprintf(w.options.Writer, "   Press Ctrl+C to exit\n\n")
}</span>

// clearTerminal clears the terminal screen
func (w *TestWatchCoordinator) clearTerminal() <span class="cov8" title="1">{
        fmt.Fprint(w.options.Writer, "\033[2J\033[H") // ANSI escape codes
}</span>

// Ensure TestWatchCoordinator implements the WatchCoordinator interface
var _ core.WatchCoordinator = (*TestWatchCoordinator)(nil)
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
